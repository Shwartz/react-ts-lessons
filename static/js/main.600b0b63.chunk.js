(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{195:function(e,n,t){e.exports=t(359)},202:function(e,n,t){},357:function(e,n,t){},359:function(e,n,t){"use strict";t.r(n);var a=t(0),o=t.n(a),s=t(30),u=t.n(s),i=t(19),r=t(20),c=t(23),l=t(22),p=t(24),d=t(8),h=t(362),m=t(361),g=t(363),w=t(364),v=t(92),f=t.n(v),b=t(93),y=t.n(b),V=function(){return o.a.createElement("div",{className:y.a.noMatch},"404 page")},S=(t(202),function(e){function n(){return Object(i.a)(this,n),Object(c.a)(this,Object(l.a)(n).apply(this,arguments))}return Object(p.a)(n,e),Object(r.a)(n,[{key:"render",value:function(){return o.a.createElement("div",null,o.a.createElement("h1",null,"Welcome to React Typescript tutorial"),o.a.createElement("p",null,"This tutorial aims to create a step by step examples on how to build a scalable one-page application with functional programming pattern in mind"),o.a.createElement("p",null,"In the following lessons, we will extend counter from a single component to fully scalable MVVM app by using React as dom manipulation library"),o.a.createElement("p",null,"You can see the source code in Github:",o.a.createElement("a",{href:"https://github.com/Shwartz/react-ts-lessons"},"https://github.com/Shwartz/react-ts-lessons")),o.a.createElement("h4",null,"Lesson 1"),o.a.createElement("p",null,"Counter widget built based on ReactJS documentation"),o.a.createElement("h4",null,"Lesson 2"),o.a.createElement("p",null,"The same Counter widget however we moving out logic into a model."))}}]),n}(o.a.Component)),C=t(94),E=t.n(C),I=t(53),k=new E.a({highlight:function(e){return n=Object(I.highlight)(e,I.languages.javascript),'<pre class="language-javascript">'.concat(n,"</pre>");var n}}),T=function(e){var n,t=e.children;return o.a.createElement("div",{dangerouslySetInnerHTML:{__html:(n=t,k.render(n))}})},L=function(e){return"\n```javascript\n".concat(e,"\n```\n")},x=function(){var e="\n\n### Description\n\nWe will use a Counter Widget with three methods such as Add, Remove, Input and show a Total amount after a calculation.\n\n### What will you learn\n\n - How to use the *`setState`* method for *`React.Component`*\n - Use of Arrow functions in *`Render()`* method and in props\n - Use of Typescript types for Stateless Components, interface definition and props\n\n\n### Source\n\n[https://github.com/Shwartz/react-ts-lessons/tree/master/src/lesson-1](https://github.com/Shwartz/react-ts-lessons/tree/master/src/lesson-1)\n\n\n## Methods in Class (React.Component)\n\n> *`React.Component`* is a Javascript Class.\n\n> *`Stateless Component`* is a function, with a return type of React element.\n\nIt is crucial to define Prototype methods in Javascript class with *`mehtodName(){}`*, instead of *`methodName = () => {}`*.\nSecond example will assign a default value by initialising a Class.\n\nLet's take a closer look at the setState method.\n\nAs per documentation:\n> *`this.props`* and *`this.state`* may be updated asynchronously; you should not rely on their values for calculating the next state.\n\n[ReactJS.org: State updates may be asynchronous](https://reactjs.org/docs/state-and-lifecycle.html#state-updates-may-be-asynchronous)\n\n\n".concat(L("\n    ...\n    add() {\n        const {inputValue, updateValue} = this.state;\n        const result = inputValue + updateValue;\n        this.setState(\n            {\n                inputValue,\n                updateValue: result\n            }\n        );\n    }\n    ...\n"),"\n\nsetState() API accepts Object and Function. The previous example use Object to update state. Nothing wrong with an example but it could fail in some situations (also described in the documentation).\n\nThe recommended way by using Function.\n\n").concat(L("\n    ...\n    add() {\n        this.setState((currentState: IState) => {\n            const {inputValue, updateValue} = currentState;\n            const result = inputValue + updateValue;\n            return {inputValue, updateValue: result};\n        });\n    }\n    ...\n"),"\n\nCallback in *`setState`* according to API returns current State and Props. That means you will be safe in the asynchronous application.\n\nWhen using this approach, there is no need for *`this`* statement inside the callback.\n\n\nThere is nothing wrong to use *`setState`* with a passing Object. Use this approach when you do not depend on a current State.\n\n").concat(L("\n    ...\n    updateValue(value: number) {\n        this.setState({\n            inputValue: value\n        });\n    }\n    ...\n"),"\n\n## Render method\n\n>There are some rumours about performance issues when using arrow function inside the method you passing to a component. Since this is a sensitive subject, I suggest to read this article, and that should settle any doubts.\n> [React, Inline Functions, and Performance](https://cdb.reacttraining.com/react-inline-functions-and-performance-bdff784f5578)\n\nThe recommended approach to defining all the State values at the top of the render() function\n\n").concat(L("\n    ...\n    render() {\n        const {inputValue, updateValue} = this.state;\n    ...\n"),"\n\nInstead of passing methods to another React component use callback in your component. This way you won't need to pass *`this`* around or even worse to use an ugly *`.bind(this)`*.\n\n\n").concat(L("\n    ...\n    add={() => {\n            this.add()\n        }}\n    ...\n"),"\n\nIn our case, we do not use a callback. Therefore we could write arrow function without closure.\n\n*`() => this.add() `*\n\nHowever, to make code consistent, I suggest using closers always like in the example above.\n\nFor a case when callback returns an argument, it would make sense to show returning type.\n\n").concat(L("\n    <InputWidget\n    ...\n        change={(val: number) => {\n            return this.updateValue(val)\n            }\n        }\n    />\n"),"\n\n## Stateless Components\n\nTo use the full power of a Typescript add types to all props. By adding types, you will help to avoid extra type check and depends on your favourite Editor/IDE it might show all types in advance which is pretty awesome.\n\nIn our widget, we have three callbacks and one static value, which is a number.\n\n").concat(L("\n    interface IProps {\n        change: (value: number) => void;\n        add: () => void;\n        remove: () => void;\n        inputValue: number;\n    }\n"),"\n\nTo use the full power of a Typescript add types to all props. By adding types, you will help to avoid extra type check and depends on your favourite Editor/IDE it might show all types in advance which is pretty awesome.\n\nIn our widget, we have three callbacks and one static value, which is a number.\n\n").concat(L("\n    <Button\n        ...\n        onClick={() => {\n            add();\n        }}\n    >\n"),"\n\nLet's explore onChange handler in the Input component\n\n").concat(L("\n    <Input\n        ...\n        onChange={({currentTarget}) => {\n            change(+currentTarget.value);\n        }}\n        ...\n    />\n"),"\nThe *`onChange`* returns *`React.ChangeEvent`* as an argument. We are interested in value which we can get from *`currentTarget.value`*. The problem is that this property return type is a string. So, we need to convert it to a number which is done by adding *`+`* sign.\n\n## Improvements\n\nSo, we have a cute tiny widget which can calculate some value. We can change the value what we want to add or remove from the total. What if we're going to reuse this widget inside in some other component?\n\nIn that case, we would need to copy over all the methods.\n\nWhat if we want the same component but instead of add or remove to have other operations? So, we would need to change a label and add new methods.\n\nThis approach could become messy as we would create similar but not the same Components and in some case, they would do one thing in other case something else.  How to write tests for this approach?\n\nLet's move to Lesson 2 and try to improve our Counter Widget.\n");return o.a.createElement(o.a.Fragment,null,o.a.createElement(T,null,e),o.a.createElement("p",{className:"end"},"~ ~ ~ end ~ ~ ~"))},j=t(54),_=t.n(j),W=function(e){var n=e.change,t=e.add,s=e.remove,u=e.inputValue;return o.a.createElement(a.Fragment,null,o.a.createElement("div",{className:_.a.buttons},o.a.createElement(d.a,{variant:"contained",onClick:function(){s()}},"Remove ",u),o.a.createElement(d.a,{variant:"contained",onClick:function(){t()}},"Add ",u)),o.a.createElement(d.d,{type:"number",value:u,onChange:function(e){var t=e.currentTarget;n(+t.value)},className:_.a.inputValue}))},O=t(38),N=t.n(O),R=function(e){function n(e){var t;return Object(i.a)(this,n),(t=Object(c.a)(this,Object(l.a)(n).call(this,e))).state={inputValue:5,updateValue:0},t}return Object(p.a)(n,e),Object(r.a)(n,[{key:"add",value:function(){this.setState(function(e){var n=e.inputValue;return{inputValue:n,updateValue:n+e.updateValue}})}},{key:"remove",value:function(){this.setState(function(e){var n=e.inputValue;return{inputValue:n,updateValue:e.updateValue-n}})}},{key:"updateValue",value:function(e){this.setState({inputValue:e})}},{key:"render",value:function(){var e=this,n=this.state,t=n.inputValue,a=n.updateValue;return o.a.createElement("div",{className:N.a.lesson1},o.a.createElement("h1",null,"Lesson 1 - Simple counter"),o.a.createElement("h3",null,"Counter Widget demo"),o.a.createElement("div",{className:N.a.codeDemo},o.a.createElement("p",{className:N.a.output},"Total: ",a),o.a.createElement(W,{add:function(){e.add()},remove:function(){e.remove()},inputValue:t,change:function(n){e.updateValue(n)}})),o.a.createElement(x,null))}}]),n}(a.Component),A="\n### Description\n\nThis is the same Counter Widget with the same methods. However, we are going to abstract Labels and Namings for the widget which would give as reusable Widget. We will introduce the Model which will keep methods for the widget separate to avoid copy/paste when re-using widget.\n\n### What will you learn\n\n - Create counter Class and move functionality outside Component\n - Handle communication between counter Class and Component\n\n### Source\n\n[https://github.com/Shwartz/react-ts-lessons/tree/master/src/lesson-2](https://github.com/Shwartz/react-ts-lessons/tree/master/src/lesson-2)\n\n## Counter Class\n\nLet's move all functionality outside to the Counter component.\n\n> The main advantage is that functionality doesn't depend on ReactJS and you can use directly to React Native or any other library or framework. Counter component won't change.\n\nA current example is just a small use case. However, imagine an enterprise level app in an agile dev environment where functionality changes are a day to day requirement.\n\nLet's create Counter Object where we can collect *`inputValue`* and *`updateValue`*.\n\n".concat(L("\nexport interface IScope {\n    inputValue: number;\n    updateValue: number;\n}\n    ...\n"),"\n\nAs per Counter component we need the following methods: *`get()`*, *`set()`*, *`update()`* Also, we add *`clear()`* method in a case Counter is not needed anymore. We use *`constructor()`* to initialise a class.\n\n").concat(L("\nclass Counter {\n    private handlers: TCallback[];\n    private scope: IScope;\n\n    constructor() {\n    }\n\n    set() {\n    }\n\n    get() {\n    }\n\n    update() {\n    }\n\n    clear() {\n    }\n}    ...\n"),"\n\nScope and handlers initialised for handling class state.\n\nIn a *`constructor`*, we set *`initialScope`* which is mandatory.\n\n").concat(L("\n...\nconstructor(initialScope: IScope) {\n    this.scope = initialScope;\n}\n...\n"),"\n\nThen methods *`set`* and *`get`* will handle scope updates.\n\n").concat(L("\n...\nset(scope: IScope) {\n    this.scope = scope;\n    this.handlers.forEach((handler) => {\n        handler(scope);\n    });\n}\n\nget() {\n    return this.scope;\n}\n...\n"),"\n\nBear in mind, any time we set new scope, we notify handlers as well.\nRemember in the Class *`Lesson2.tsx`* we are calling *`this.counter.update()`* and passing a callback method with a *`setState`*. This concept is a mega important to understand. It took me some time to crack it.\n\n").concat(L("\n// example from Lesson2.tsx\n...\nthis.counter.update((scope: IScope) => {\n    this.setState(scope);\n});\n...\n"),"\n\nSo, here we are collecting listeners, with the *`update()`* method.\n").concat(L("\n...\nupdate(handler: TCallback) {\n    this.handlers = [...this.handlers, handler];\n}\n\nclear() {\n    this.handlers = [];\n}\n...\n"),"\n\nSince we created a method to *`update()`* we need to create a method to remove as well. Therefore there is *`clear()`* to remove all the handlers before we are removing a component.\n\nNow, we have a class, with getters and setters. However, regards to the counter, there is no counter functionality yet.\n\nLet's add methods for the counter. Each method will update ALL ENTIRE SCOPE!\n\n").concat(L("\n...\nadd() {\n    const {inputValue, updateValue} = this.scope;\n    const result = inputValue + updateValue;\n    this.set({inputValue, updateValue: result});\n}\n\nremove() {\n    const {inputValue, updateValue} = this.scope;\n    const result = updateValue - inputValue;\n    this.set({inputValue, updateValue: result});\n}\n\ninputChange(value: number) {\n    const {updateValue} = this.scope;\n    this.set({inputValue: value, updateValue});\n}\n...\n"),"\n\n> There is a place for improvements but let's leave that for the Lesson3\n\nHere is a full class.\n\n\n").concat(L("\nexport interface IScope {\n    inputValue: number;\n    updateValue: number;\n}\n\ntype TCallback = (scope: IScope) => void;\n\nclass Counter {\n    private handlers: TCallback[] = [];\n    private scope: IScope;\n\n    constructor(initialScope: IScope) {\n        this.scope = initialScope;\n    }\n\n    add() {\n        const {inputValue, updateValue} = this.scope;\n        const result = inputValue + updateValue;\n        this.set({inputValue, updateValue: result});\n    }\n\n    remove() {\n        const {inputValue, updateValue} = this.scope;\n        const result = updateValue - inputValue;\n        this.set({inputValue, updateValue: result});\n    }\n\n    inputChange(value: number) {\n        const {updateValue} = this.scope;\n        this.set({inputValue: value, updateValue});\n    }\n\n    set(scope: IScope) {\n        this.scope = scope;\n        this.handlers.forEach((handler) => {\n            handler(scope);\n        });\n    }\n\n    get() {\n        return this.scope;\n    }\n\n    update(handler: TCallback) {\n        this.handlers = [...this.handlers, handler];\n    }\n\n    clear() {\n        this.handlers = [];\n    }\n}\n\nexport const counter = (initialScope: IScope) => new Counter(initialScope);\n"),"\n\n\nIn case you wonder about this line\n\n*`export const counter = (initialScope: IScope) => new Counter(initialScope);`*\n\nInitialising is done to avoid using *`new`* every time we are using a Counter component, kind of shortcut.\n\n\nIn Lesson2 class, we don't need to add any more methods. We connect (don't want to use the word *`hook`* :)) together *`setState`* and *`counter.update`*.\n\n").concat(L("\n...\nconst initialState: IScope = {\n    inputValue: 5,\n    updateValue: 0\n};\n\nexport class Lesson2 extends Component<IProps> {\nstate: IScope;\ncounter = counter(initialState);\n\nconstructor(props: IProps) {\n    super(props);\n    this.state = this.counter.get();\n    this.counter.update((scope: IScope) => {\n        this.setState(scope);\n    });\n}\n...\n"),"\n\nWe initialise a Counter component with initial State. With *`this.state = this.counter.get();`* we bind, initial values from Counter component.\nNow, for *`inputWidget`*, we expose counter class methods to buttons.\n\n").concat(L("\n\n...\nrender() {\n    const {inputValue, updateValue} = this.state;\n\n    return (\n        <div className={styles.Lesson2}>\n            <h1>Lesson 2 - Simple Counter</h1>\n\n            <h3>Counter Widget Demo</h3>\n\n            <div className={styles.codeDemo}>\n                <p className={styles.output}>Total: {updateValue}</p>\n                <InputWidget\n                    leftButtonHandler={\n                        () => {\n                            this.counter.remove();\n                        }\n                    }\n                    rightButtonHandler={\n                        () => {\n                            this.counter.add();\n                        }\n                    }\n                    leftButtonLabel={`Remove`}\n                    rightButtonLabel={`Add`}\n                    inputChange={\n                        (value: number) => {\n                            this.counter.inputChange(value);\n                        }\n                    }\n                    inputValue={inputValue}\n                />\n            </div>\n\n            <Description />\n        </div>\n    );\n}\n...\n"),"\n\nWe now have a generic approach to our button labels and methods. That means, now we can use this component outside of the Counter app and change labels and methods for entirely different tasks.\n\n"),B=function(){return o.a.createElement(o.a.Fragment,null,o.a.createElement(T,null,A),o.a.createElement("p",{className:"end"},"~ ~ ~ end ~ ~ ~"))},D=t(97),H=function(){function e(n){Object(i.a)(this,e),this.handlers=[],this.scope=void 0,this.scope=n}return Object(r.a)(e,[{key:"add",value:function(){var e=this.scope,n=e.inputValue,t=n+e.updateValue;this.set({inputValue:n,updateValue:t})}},{key:"remove",value:function(){var e=this.scope,n=e.inputValue,t=e.updateValue-n;this.set({inputValue:n,updateValue:t})}},{key:"inputChange",value:function(e){var n=this.scope.updateValue;this.set({inputValue:e,updateValue:n})}},{key:"set",value:function(e){this.scope=e,this.handlers.forEach(function(n){n(e)})}},{key:"get",value:function(){return this.scope}},{key:"update",value:function(e){this.handlers=[].concat(Object(D.a)(this.handlers),[e])}},{key:"clear",value:function(){this.handlers=[]}}]),e}(),M=function(e){return new H(e)},P=t(55),F=t.n(P),J=function(e){var n=e.leftButtonHandler,t=e.leftButtonLabel,s=e.rightButtonHandler,u=e.rightButtonLabel,i=e.inputChange,r=e.inputValue;return o.a.createElement(a.Fragment,null,o.a.createElement("div",{className:F.a.buttons},o.a.createElement(d.a,{variant:"contained",onClick:function(){return n()}},t," ",r),o.a.createElement(d.a,{variant:"contained",onClick:function(){return s()}},u," ",r)),o.a.createElement(d.d,{type:"number",value:r,onChange:function(e){var n=e.currentTarget.value;return i(+n)},className:F.a.inputValue}))},z=t(39),U=t.n(z),q={inputValue:5,updateValue:0},G=function(e){function n(e){var t;return Object(i.a)(this,n),(t=Object(c.a)(this,Object(l.a)(n).call(this,e))).state=void 0,t.counter=M(q),t.state=t.counter.get(),t.counter.update(function(e){t.setState(e)}),t}return Object(p.a)(n,e),Object(r.a)(n,[{key:"render",value:function(){var e=this,n=this.state,t=n.inputValue,a=n.updateValue;return o.a.createElement("div",{className:U.a.Lesson2},o.a.createElement("h1",null,"Lesson 2 - Simple Counter"),o.a.createElement("h3",null,"Counter Widget Demo"),o.a.createElement("div",{className:U.a.codeDemo},o.a.createElement("p",{className:U.a.output},"Total: ",a),o.a.createElement(J,{leftButtonHandler:function(){e.counter.remove()},rightButtonHandler:function(){e.counter.add()},leftButtonLabel:"Remove",rightButtonLabel:"Add",inputChange:function(n){e.counter.inputChange(n)},inputValue:t})),o.a.createElement(B,null))}}]),n}(a.Component),K=function(e){function n(){var e,t;Object(i.a)(this,n);for(var a=arguments.length,o=new Array(a),s=0;s<a;s++)o[s]=arguments[s];return(t=Object(c.a)(this,(e=Object(l.a)(n)).call.apply(e,[this].concat(o)))).state={selectedIndex:0},t.handleListItemClick=function(e,n){t.setState({selectedIndex:n})},t}return Object(p.a)(n,e),Object(r.a)(n,[{key:"render",value:function(){var e=this;return o.a.createElement(h.a,{basename:"/react-ts-lessons"},o.a.createElement("div",{className:f.a.App},o.a.createElement(d.b,null),o.a.createElement(d.c,{container:!0,spacing:16},o.a.createElement(d.c,{item:!0,sm:4,xs:12},o.a.createElement(d.e,{component:"nav"},o.a.createElement(m.a,{to:"/"},o.a.createElement(d.f,{button:!0,selected:1===this.state.selectedIndex,onClick:function(n){return e.handleListItemClick(n,1)}},"Home")),o.a.createElement(m.a,{to:"/lesson-1"},o.a.createElement(d.f,{button:!0,selected:2===this.state.selectedIndex,onClick:function(n){return e.handleListItemClick(n,2)}},"Lesson 1 - Simple counter")),o.a.createElement(m.a,{to:"/lesson-2"},o.a.createElement(d.f,{button:!0,selected:3===this.state.selectedIndex,onClick:function(n){return e.handleListItemClick(n,3)}},"Lesson 2 - Simple counter")))),o.a.createElement(d.c,{item:!0,sm:8,xs:12},o.a.createElement("section",null,o.a.createElement(g.a,null,o.a.createElement(w.a,{exact:!0,path:"/",component:S}),o.a.createElement(w.a,{path:"/lesson-1",component:R}),o.a.createElement(w.a,{path:"/lesson-2",component:G}),o.a.createElement(w.a,{component:V})))))))}}]),n}(a.Component);t(357),Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));u.a.render(o.a.createElement(K,null),document.getElementById("root")),"serviceWorker"in navigator&&navigator.serviceWorker.ready.then(function(e){e.unregister()})},38:function(e,n,t){e.exports={codeDemo:"Lesson1_codeDemo__1-_Pe",output:"Lesson1_output__10ADM"}},39:function(e,n,t){e.exports={codeDemo:"Lesson2_codeDemo__2qKgf",output:"Lesson2_output__3Nmk0"}},54:function(e,n,t){e.exports={inputValue:"InputWidget_inputValue__2QM0w",buttons:"InputWidget_buttons__UPT99"}},55:function(e,n,t){e.exports={inputValue:"InputWidget_inputValue__hWEDH",buttons:"InputWidget_buttons__1MhTv"}},92:function(e,n,t){e.exports={App:"App_App__GDdpt"}},93:function(e,n,t){e.exports={noMatch:"NoMatch_noMatch__1_Oca"}}},[[195,2,1]]]);
//# sourceMappingURL=main.600b0b63.chunk.js.map